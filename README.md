# 炼丹蓝图 开发日志

> 这份文档记录了整个项目从零开始的开发过程，包括每一步的想法、决策和具体操作。
>
> **文档用途：**
> - 梳理开发思路，让自己想清楚再动手
> - 方便团队成员了解项目进度和变更原因
> - 作为个人学习和成长的记录

---

## 一、开发原则

开发过程中遵循的核心原则：

| 原则 | 说明 |
|------|------|
| **KISS** | 保持简单，别搞复杂 |
| **MVP** | 先做核心功能，别一开始就想做大而全 |
| **DRY** | 不要重复自己，能复用就复用 |
| **YAGNI** | 用不到的功能别提前做 |

**个人补充：**
- 代码要让人看得懂，别为了炫技写得很绕
- AI可以帮忙补全代码，但别让AI一次性生成大段代码
- 注释要写大白话，别写得跟论文一样

## 二、项目目标

做一个 **AI模型架构可视化设计工具**，就像 Scratch 那样拖拖拽拽就能搭建模型。

**想解决的问题：**
- 不会写代码的人也能搭建AI模型
- 研发人员可以快速验证架构想法
- 降低AI架构设计的门槛

## 三、技术栈

| 类型 | 技术 |
|------|------|
| 前端框架 | React |
| 可视化库 | React Flow |
| UI组件库 | heroUI |
| 构建工具 | Vite |
| 前端语言 | JavaScript |
| 后端语言 | Python |
| ML框架 | PyTorch |

## 四、开发计划

### 前端（已完成）

| 阶段 | 任务 | 状态 |
|------|------|------|
| 1 | 搭建基础环境，接入 React Flow | ✅ 完成 |
| 2 | 封装通用节点组件 | ✅ 完成 |
| 3 | 实现类似 Scratch 的交互操作 | ✅ 完成 |

### 后端（当前开发）

| 阶段 | 任务 |
|------|------|
| 1 | 节点定义系统：用修饰器定义节点，导出配置给前端 |
| 2 | 执行引擎：解析蓝图结构，自动构建计算图 |
| 3 | 验证评估：测试数据流通性，跑分 |

### 前后端通信（待开发）

| 阶段 | 任务 |
|------|------|
| 1 | 架构下发：前端把模型架构发给后端执行 |
| 2 | 结果反馈：后端执行结果实时同步到前端 |

---

## 五、开发日志

> 下面是实际开发过程的流水账记录，按时间顺序写的。

---

### Step 1：创建项目

我执行了uv init命令，创建了一个新的Python项目。
配置了清华镜像源，加速了依赖安装。
安装了websockets和pytorch库，准备开始开发。

### Step 2：重构节点定义系统与执行引擎

为了更好地支持复杂的 AI 模型构建，我根据最新的架构要求对系统进行了重构：

1. **动态节点加载系统**：
   - **`decorators.py`**：提供了 `@category` 和 `@node` 装饰器，支持在函数级别定义节点及其元数据。
   - **`loader.py`**：实现了动态模块加载机制，自动扫描 `nodes/` 目录下的所有 Python 文件并注册节点。
   - **`registry.py`**：统一管理所有已注册的节点，并能导出符合前端 React Flow 要求的 `node_registry.json` 配置文件。

2. **标准化节点接口**：
   - 每个节点现在通过返回 `(infer, build, compute)` 三个函数来定义其行为：
     - `infer`：推断输出形状。
     - `build`：初始化 PyTorch 层或参数。
     - `compute`：执行实际的张量计算。
   - 这种结构遵循了 **DRY** 原则，将结构定义与计算逻辑分离。

3. **增强型执行引擎 (`engine.py`)**：
   - 适配了新的 `(infer, build, compute)` 节点协议。
   - 支持多输入多输出端口的数据流传递。
   - 实现了自动化的层初始化（`build`）和计算调度。
   - 验证了包括 `input`、`linear`、`math` 等多种节点的协同工作。

4. **前后端对接**：
   - 导出的 `node_registry.json` 包含了完整的分类、颜色、端口和参数定义，前端可直接用于渲染 UI。

