后端
	大体逻辑
		启动服务
		当收到前端发来的请求
			请求节点注册表
				扫描并加载所有节点生成注册表
				发送到前端
			请求运行蓝图
				运行排序
				根据类型和params
					形状推断
					算子层构建
				按照顺序执行节点
					执行完一个节点，返回
						节点
						结果
					执行出错了
						向前端发送
							节点id
							错误
						结束引擎运行
				结束引擎运行
	文件与具体逻辑
		main.py
			启动服务
				调用 server.start(host: str = "localhost", port: int = 8765)
		server.py
			全局变量
				clients：已连接的前端列表
			启动服务
				打印启动信息
				创建 WebSocket 服务
				保持运行
			处理连接
				将前端加入 clients
				循环接收消息
					收到消息，调用 handleMessage
				连接断开，从 clients 移除
			发送消息
				包装成 {type, id, data}
				转 JSON 发出去
			发送错误
				包装成 {type, id, error}
				发出去
			处理消息
				解析 JSON
				提取 type 和 id
				如果 type 是 getNodes
					调用 registry.getAllForFrontend()
					发送响应
				如果 type 是 runBlueprint
					提取 blueprint 和 inputs
					调用 engine.run()
					发送完成消息
		loader.py
			动态导入模块
				根据文件路径计算模块名
				使用 importlib 加载
			加载所有
				获取 nodes 文件夹路径
				遍历文件夹
					跳过 __pycache__
					跳过 __init__.py
					如果是 .py 文件
						动态导入模块(模块中的 @category 和 @node 装饰器会自动注册)
		registry.py
			全局变量
				nodes：节点定义字典
				categories：分类定义字典
			注册分类
				存入 categories
			注册节点
				存入 nodes
			获取前端格式数据
				遍历 categories，构建分类列表
				获取 nodes，把里面每一个的 func 去掉
				返回 {categories, nodes}
		context.py
			执行上下文类
				初始化(blueprintData)
					shapes：存每个节点的形状 {node_id: {port: shapeValue}}
					layers：存已构建的层 {nodeId: layer}
					results：存每个节点的输出 {nodeId: {port: outputValue}}
				获取节点输入(nodeId)
					遍历所有 edges
						如果 edge.target 是当前节点
							从 results 里取 source 节点的对应端口值
					返回收集到的输入字典
		engine.py
			初始化
				调用 loader.loadAll() 加载所有节点
				创建执行上下文 context
			运行蓝图(blueprint, sendMessage, sendError)
				解析 blueprint 得到 nodes 和 edges
				调用 topoSort 得到执行顺序
				获取节点定义
				执行形状推断
					遍历节点
						调用节点定义里的 infer 函数
						存入 context.shapes
				构建层实例
					遍历节点
						调用节点定义里的 build 函数
						存入 context.layers
				逐节点运行
					遍历节点
						尝试执行节点
							调用节点定义里的 compute 函数
							存入 context.results
							sendMessage
						运行出错
							sendError
							终止执行，跳出遍历
				打印完成信息
		decorators.py
			@category 装饰器
				参数：id, name, color, icon
				调用 registry.register_category
			@node 装饰器
				参数：opcode, name, category, inputs, outputs, params
				返回装饰器函数
					接收和返回 infer, build, compute 三函数
		sort.py
			拓扑排序(nodes, edges)
				构建入度表
				构建邻接表
				将入度为0的节点入队
				循环处理队列
					弹出节点，加入结果
					遍历其后继节点，入度减1
					入度变0的入队
				如果结果数量不等于节点数量
					抛异常：存在循环依赖
				返回排序结果[数组格式]
		nodes/example.py
			从装饰器导入category, node
			@category
				id="example_category"
				label="示例节点定义"
				color="#FFB6C1"
				icon="base64格式字符串"
			@node
				opcode="example_node"
				label="示例节点"
				ports={"in": ["x", "y"], "out": ["result"]}
				params={"数字参数": 1, "布尔参数": False}
				func
					infer 方法
					build 方法
					compute 方法
					返回infer_shape、build、compute这三个func
	开发要求
		遵循Occam’s Razor原则，如无必要，勿增实体。
			不要标注任何类型
			除了该架构中的方法，不要新增任何额外的函数
		遵循Postel’s Law原则，接受多变，输出保守。
			自动适配传入的参数
		面向理解编程
			代码逻辑要符合人类直觉
			每行代码都需要尾随注释，大白话详细解读每一行代码
			每个函数方法的开头都需要标明该方法的具体用法和各种调用示例
			变量名和函数名等要简洁易于理解，并且符合项目语境，全部使用驼峰命名法
		代码易于阅读
			采用积木式的行状写法
			减少嵌套与缩进