# 📄 炼丹蓝图后端项目深度解读

本文档直接说明项目结构与代码逻辑，旨在帮助开发者快速上手开发。

## 🎯 项目简介
这是一个可视化节点编辑器的后端执行引擎。
**核心功能**：接收前端发送的节点图（蓝图），解析执行逻辑，并按顺序运行节点，最后将结果返回给前端。

---

## 🛠️ 开发哲学与规范
在贡献代码前，请务必遵守以下原则：

1.  **命令式编程** 🧱
    *   代码逻辑必须直观，像流水账一样一行行执行。
    *   拒绝复杂的声明式写法，拒绝过度封装。
2.  **Postel’s Law (鲁棒性)** 🛡️
    *   **输入宽容**：代码要能自动适配各种奇怪的传入参数，不要轻易报错。
    *   **输出严谨**：传给别人的数据格式必须严格遵守定义。
3.  **可读性第一** 📖
    *   **变量命名**：使用全称，驼峰命名法 (ExampleNode)，禁止缩写。
    *   **注释**：每一行关键代码必须有尾随注释，用大白话解释这一行在干什么。
    *   **结构**：减少缩进和嵌套，让代码看起来是扁平的。

---

## 🚀 整体运行流程
后端启动后，数据流向如下：

1.  **启动**：`main.py` 调用 `server.py` 启动 WebSocket 服务。
2.  **加载**：`loader.py` 扫描 `nodes/` 文件夹，自动导入所有节点文件。
3.  **注册**：节点文件被导入时，`@node` 装饰器自动将节点信息存入 `registry.py`。
4.  **连接**：前端建立 WebSocket 连接。
5.  **交互**：
    *   **获取列表**：前端请求 `getRegistry` -> 后端返回所有可用节点。
    *   **运行蓝图**：前端发送 `runBlueprint` -> 后端 `engine.py` 开始执行。
6.  **执行**：
    *   `sort.py` 计算节点执行顺序。
    *   `engine.py` 按顺序执行节点 `compute` 方法。
    *   实时将结果通过 WebSocket 发回前端。

---

## 📂 文件详细解读

### 1. `main.py` (入口)
*   **功能**：程序的启动入口。
*   **逻辑**：非常简单，只做一件事——导入 `server` 模块并调用 `server.start()` 启动服务。

### 2. `server.py` (服务器)
*   **功能**：WebSocket 服务器，负责与前端通讯。
*   **核心方法**：
    *   `start()`: 启动 WebSocket 监听。
    *   `handleConnection()`: 维护连接池 (`clients`)。
    *   `handleMessage()`: 消息分发中心。
        *   收到 `getRegistry`: 调用 `registry.getAllForFrontend()` 返回节点表。
        *   收到 `runBlueprint`: 调用 `engine.run()` 执行蓝图。
    *   `sendMessage()` / `sendError()`: 统一的消息发送封装，确保 JSON 格式正确。

### 3. `loader.py` (加载器)
*   **功能**：自动化加载节点文件。
*   **逻辑**：
    *   获取 `nodes/` 目录的绝对路径。
    *   遍历目录下所有 `.py` 文件（排除 `__init__.py`）。
    *   使用 `importlib` 动态导入这些模块。
    *   **作用**：只要你在 `nodes/` 下新建了文件，系统启动时就会自动发现，无需手动去 `main.py` 注册。

### 4. `registry.py` (注册表)
*   **功能**：存储和管理所有节点的数据结构。
*   **核心数据**：
    *   `nodes`: 字典，存储 `{opcode: 节点类及配置}`。
    *   `categories`: 字典，存储节点的分类信息（如颜色、标签）。
*   **核心方法**：
    *   `@node`: 装饰器。用于标记一个类是节点，自动将其注册到 `nodes` 字典中。
    *   `getAllForFrontend()`: 将后端存储的数据转换成前端需要的 JSON 格式（去除 Python 类对象等无法序列化的内容）。
    *   `createNode()`: 根据 `opcode`（节点ID）实例化一个节点对象。

### 5. `engine.py` (执行引擎)
*   **功能**：解析蓝图并执行节点逻辑。
*   **核心逻辑 (`run` 函数)**：
    1.  **拓扑排序**：调用 `sort.topoSort` 获取正确的执行顺序列表。
    2.  **实例化**：遍历所有节点 ID，调用 `registry.createNode` 创建实例。
    3.  **执行循环**：
        *   按顺序遍历节点。
        *   **准备输入**：查找当前节点的输入端口连接了哪个上游节点，从 `results` 字典中取出上游节点的输出值。
        *   **计算**：调用节点实例的 `compute(input)` 方法。
        *   **存储**：将计算结果存入 `results` 字典，供下游节点使用。
        *   **反馈**：将结果发送给前端。

### 6. `sort.py` (排序)
*   **功能**：拓扑排序算法。
*   **作用**：确保节点按依赖关系执行。如果 B 依赖 A 的输出，那么 A 必须排在 B 前面。
*   **异常**：如果发现循环依赖（A连B，B连A），会直接报错。

### 7. `nodes/` (节点目录)
*   **功能**：存放具体的节点业务逻辑。
*   **结构**：
    *   `base.py`: 包含 `InputNode`, `OutputNode` 等基础节点。
    *   `example.py`: 包含参数使用示例。
    *   开发者应在此目录下创建新的 `.py` 文件来添加新节点。

---

## 📝 如何开发新节点

按照以下步骤添加一个新节点（例如：加法节点）：

### 步骤 1：新建文件
在 `nodes/` 目录下创建一个新文件，例如 `nodes/my_nodes.py`。

### 步骤 2：编写代码
直接复制以下模板并修改：

```python
from registry import node, BaseNode

# @node 装饰器必填，用于注册节点
@node(
    opcode="my_add_node",      # 唯一标识符，前端根据这个找到对应的节点
    label="我的加法",           # 前端显示的名称
    ports={
        "input": {"a": "数值A", "b": "数值B"},  # 输入端口定义
        "output": {"result": "结果"}           # 输出端口定义
    },
    params={                   # 节点自身的参数（非连线输入）
        "scale": {"label": "缩放倍数", "type": "int", "value": 1}
    }
)
class MyAddNode(BaseNode):     # 必须继承 BaseNode
    def compute(self, input):  # 必须实现 compute 方法
        # 1. 获取输入数据（来自上游节点）
        val_a = input.get("a", 0)
        val_b = input.get("b", 0)
        
        # 2. 获取参数设置（来自右侧面板）
        scale = self.params["scale"]["value"]
        
        # 3. 执行业务逻辑
        res = (val_a + val_b) * scale
        
        # 4. 返回结果（key 必须对应 ports 中的 output）
        return {"result": res}
```

### 步骤 3：生效
保存文件，重新运行 `main.py`。新节点会自动出现在前端菜单中。
